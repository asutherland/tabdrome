## Overview ##

The annotated tab representation bundles up all the information we have about
tabs in a single object structure.

### Annotated Tabs ###

The annotated tab object has the following keys and corresponding values:
* normTab: The normalized tab representation documented in normalized_tabs.md.
  This is the information Firefox directly provides about the tab.  Indirect
  information such as history/bookmark information is provided by context
  searchers because of the asynchronous and non-trivial effort involved.
* tabMeta: Persistent data set on the tab via actions.
* siteMeta: Persistent data set on any portion of the URL (the TLD+1, the
  origin, path segments along the URL, the specific URL, etc.)
* dug: Data extracted from URLs or page contents via content diggers.  Although
  URL digging happens synchronously, page-content-based digging is asynchronous.
* searched: Data provided by (asynchronous) context searchers.
* analyzed: Data generated by tab analysis rules, derived from all of the prior
  sources (normTab, tabMeta, siteMeta, dug, searched).
* aggr: The precedence-merged results from all of the

### Our definition of "Data" ###

Data consists of:
* Tags: Boolean tags.  They are familiar and conceptually simple for simple
  things.
* Anti-tags: Tags run into difficulties when there are layers of decision logic.
  What if origin-level siteMeta says there's a tag, but more specific URL-level
  doesn't want there to be a tag?  While convention with tag naming and rule
  logic can approximate this (ex: `if there's a "foo" tag but not a "!foo"
  tag`), explicit anti-tags both avoid this boilerplate and can provide for
  more complex cases like a tag negated by an anti-tag but then re-instantiated
  by a higher precedence (non-anti) tag.
* Simple variables: Named data with a boolean, string, or numeric type.  Tags
  only scale so far before something richer is necessary.  Variables exist in a
  separate namespace from tags.
* Schema-typed/named complex payloads.  These are things like the breadcrumb
  schema.  There's a specific, strict object hierarchy.  For now these schemas
  must all be built-in.

For each of tabMeta, siteMeta, dug, searched, analyzed, their contents are
exposed as the following:
  * tags
  * antiTags
  * simpleVars
  * schemaPayloads

This all begs the question of whether this is creating an ad-hoc programming
language with an ad-hoc data model.  The answer is clearly yes.  From a
"re-inventing the wheel" perspective, this is undesirable.  However, it's
currently believed to be acceptable in the name of security and since the
blockly-based programming UI abstracts away the implementation details.  It
should be feasible to replace the mechanism under the hood in the future, etc.
